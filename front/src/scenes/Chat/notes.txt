Un utilisateur essaye de rejoindre un channel :

- l'utilisateur n'est pas membre du channel et ce dernier est public --> il le rejoint

- le channel est privé --> l'utilisateur a besoin d'une invitation 
  ET/OU le propriétaire du channel doit approuver la demande pour rejoindre

- le channel est protégé par mot de passe : l'utilisateur doit fournir le bon mdp pour rejoindre

- l'utilisateur est deja membre du channel

- Le channel est plein

- L'utilisateur a ete bloque par le propriétaire du channel ou
  par l'administrateur

- L'utilisateur a été banni du channel

-------------------------------------------------------------------------------
TODO :

1) Je ne dois pas pouvoir m'envoyer un message
2) Gérer le cas de l'utilisateur débloqué
3) Empêcher l'utilisateur bloqué d'envoyer des messages si la conversation est ouverte

------------------------------------------------------------------------------------------------
Comment connecter le backend avec le frontend ?

Je dois socket.emit() les événements blockUser et unblockUser dans le front.
Par exemple, le bouton "Block" pourrait émettre blockUser avec l'id de l'utilisateur à bloquer
const handleBlock = () =>
{
  socket.emit('blockUser', { blockerId: currentUserId, blockedId: userIdToBlock });
}

Je peux également écouter les événements userBlocked, userUnblocked et error
via un gestionnaire d'events pour maj. l'interface user en fonction de l'event

const socket = io('http://localhost:8080');

socket.on('userBlocked', function(data)
{
  console.log('L'utilisateur a été bloqué : ', data);
  // Ici, vous pouvez mettre à jour votre interface utilisateur en conséquence
});

socket.on('error', function(data)
{
  console.log('Une erreur s'est produite : ', data);
});

------------------------------------------------------------------------------------------------
Logique des DM 

1) L'utilisateur enclenche onDirectMessageClick() en cliquant sur "Direct Message" dans User.

2) onDirectMessageClick() est passee en tant que prop au composant User dans UsersList.

3) Elle met a jour la fonction setPrivateMessageUserId avec l'id de l'user actuel.

4) setPrivateMessageUserId est une fonction de maj. d'etat definie dans MainPage.tsx
   Elle est passee en tant que prop a UsersList.
   Donc onDirectMessageClick, une fois enclenchee, utilise setPrivateMessageUserId pour maj.
   l'etat de privateMessageUserId avec l'id de l'user actuel.

Voici a quoi ressemble mon composant User : "import { MouseEvent, useState, useContext, useEffect } from 'react';
import { io } from "socket.io-client";
import { UserInfos } from "../../../services/interfaces/userInfos.interface";
import Block from "../Block/Block";
import axios from 'axios';

const User = (
	{
		user,
		isActive,
		onClick,
		onDirectMessageClick,
		navigate,
		// handleBlockClick // POUR LE BLOCAGE
  	}:
	{
		user: UserInfos;
		isActive: boolean;
		onClick: (event: MouseEvent<HTMLElement>) => void;
		onDirectMessageClick: () => void;
		navigate: (path: string) => void;
		// handleBlockClick: () => void; // POUR LE BLOCAGE
	}) =>
{
	const [userInfos, setUserInfos] = useState<UserInfos | null>(null);
	const [showNotification, setShowNotification] = useState(false);
	const token = localStorage.getItem("token");
	const socket = io("http://localhost:8080");

	useEffect(() =>
	{
		const getCurrentUser = async () =>
		{
			try
			{
				const response = await axios.get("http://localhost:8080/users/me",
				{
				  headers:
				  {
					Authorization: `Bearer ${token}`,
				  },
				});

				setUserInfos(response.data);
			  }
			  catch (error)
			  {
				console.error("Failed to fetch users.");
			  }
			};

			getCurrentUser();
		}, [token]);

	const handleBlockClick = () =>
	{
		socket.emit('blockUser', {blockerId: user.id, blockedId: blockedId });
		setShowNotification(true);
	}

	useEffect(() =>
	{
		socket.on('userBlocked', () =>
		{
			console.log('User blocked successfully');
			// Vous pouvez ajouter ici d'autres actions à effectuer lorsque l'utilisateur est bloqué avec succès
		});
	
		return () =>
		{
			socket.off('userBlocked');
		};
	}, []);

	return (
		<div key={user.id} className={`user ${isActive ? 'show-menu' : ''}`}>
			{showNotification && (
				<Block
					message="User has been blocked"
					onClose={() => setShowNotification(false)}
				/>
			)}
			<p className="username" onClick={onClick}>{user.name}</p>
			{isActive &&
			(
				<ul className="dropdown-menu">
					<li className="dropdown-item" onClick={() => navigate(`/profile/${user.id}`)}>
						Profile
					</li>

					<li className="dropdown-item" onClick={onDirectMessageClick}>
  						Direct Message
					</li>

					<li className="dropdown-item" onClick={() => console.log('Profile clicked')}>
						Add friend
					</li>

					<li className="dropdown-item" onClick={handleBlockClick}>
						Block
					</li>

					<li className="dropdown-item" onClick={() => console.log('Invite to Pong clicked')}>
						Invite to Pong
					</li>
				</ul>
			)}
			<div className={user.connected ? 'online' : 'offline'}>
				{user.isPlaying ?
					<>
						<div className="playing-indicator" />
						<span>Playing</span>
					</> :
					(user.connected ?
					<>
						<div className="online-indicator" />
						<span>Online</span>
					</> :
					<>
						<div className="offline-indicator" />
						<span>Offline</span>
					</>)
				}
			</div>
		</div>
	);
};

export default User;". Avec la requete Get a la route 'http://localhost:8080/users/me", je recupere l'id de l'user actuellement connecte, donc je l'utilise comme blockerId. Par contre comment je recupere l'id de l'user qui s'est fait bloquer ("blockedId") ? 

La logique pour recuperer blockedId doit etre semblable a celle pour recuperer 

N'hesite pas a modifier User.tsx si j'ai fais quelque chose de mal.

Tu penses pas que je devrais definir handleBlockClick dans un autre fichier ?