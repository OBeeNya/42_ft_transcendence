Un utilisateur essaye de rejoindre un channel :

- l'utilisateur n'est pas membre du channel et ce dernier est public --> il le rejoint

- le channel est privé --> l'utilisateur a besoin d'une invitation 
  ET/OU le propriétaire du channel doit approuver la demande pour rejoindre

- le channel est protégé par mot de passe : l'utilisateur doit fournir le bon mdp pour rejoindre

- l'utilisateur est deja membre du channel

- Le channel est plein

- L'utilisateur a ete bloque par le propriétaire du channel ou
  par l'administrateur

- L'utilisateur a été banni du channel

-------------------------------------------------------------------------------

Code :
- fonction qui recherche un channel dans notre db 
- fonction qui verifie si le nom du channel existe deja dans la db
--> si oui le rejoint (si pas private), sinon msg d'erreur

-------------------------------------------------------------------------------
Blocage

-------------------------------------------------------------------------------
DM logique

L'utilisateur actuel clique sur "Direct Message" dans le menu deroulant
--> declenche onDirectMessageClick() definie dans UsersList.tsx (composant parent de User)

"1. Assurez-vous que les événements émis par le client dans le front-end correspondent
exactement à ceux que le serveur attend. Par exemple, si vous envoyez
socket.emit('userConnected', userId) dans le front-end, assurez-vous que vous avez un
gestionnaire pour 'userConnected' dans le back-end, ce qui est bien le cas dans
votre code." : FAIT

"2. Assurez-vous que les données envoyées correspondent à ce que le back-end attend.
Par exemple, dans votre back-end, pour 'blockUser', vous attendez un objet avec
blockerId et blockedId. Assurez-vous que le front-end envoie ces mêmes données." : FAIT

TODO :
1) Gérer le cas de l'utilisateur débloqué
2) Empêcher l'utilisateur bloqué d'envoyer des messages si la conversation est ouverte

Comment connecter le backend avec le frontend ?

Je dois socket.emit() les événements blockUser et unblockUser dans le front.
Par exemple, le bouton "Block" pourrait émettre blockUser avec l'id de l'utilisateur à bloquer
const handleBlock = () =>
{
  socket.emit('blockUser', { blockerId: currentUserId, blockedId: userIdToBlock });
}

Je peux également écouter les événements userBlocked, userUnblocked et error
via un gestionnaire d'events pour maj. l'interface user en fonction de l'event

const socket = io('http://localhost:8080');

socket.on('userBlocked', function(data)
{
  console.log('L'utilisateur a été bloqué : ', data);
  // Ici, vous pouvez mettre à jour votre interface utilisateur en conséquence
});

socket.on('error', function(data)
{
  console.log('Une erreur s'est produite : ', data);
});

