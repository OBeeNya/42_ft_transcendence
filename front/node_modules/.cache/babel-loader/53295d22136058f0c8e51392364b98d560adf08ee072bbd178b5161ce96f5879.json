{"ast":null,"code":";\n(function () {\n  // This would be the place to edit if you want a different\n  // Base32 implementation\n\n  var alphabet = '0123456789abcdefghjkmnpqrtuvwxyz';\n  var alias = {\n    o: 0,\n    i: 1,\n    l: 1,\n    s: 5\n  };\n\n  /**\n   * Build a lookup table and memoize it\n   *\n   * Return an object that maps a character to its\n   * byte value.\n   */\n\n  var lookup = function () {\n    var table = {};\n    // Invert 'alphabet'\n    for (var i = 0; i < alphabet.length; i++) {\n      table[alphabet[i]] = i;\n    }\n    // Splice in 'alias'\n    for (var key in alias) {\n      if (!alias.hasOwnProperty(key)) continue;\n      table[key] = table['' + alias[key]];\n    }\n    lookup = function () {\n      return table;\n    };\n    return table;\n  };\n\n  /**\n   * A streaming encoder\n   *\n   *     var encoder = new base32.Encoder()\n   *     var output1 = encoder.update(input1)\n   *     var output2 = encoder.update(input2)\n   *     var lastoutput = encode.update(lastinput, true)\n   */\n\n  function Encoder() {\n    var skip = 0; // how many bits we will skip from the first byte\n    var bits = 0; // 5 high bits, carry from one byte to the next\n\n    this.output = '';\n\n    // Read one byte of input\n    // Should not really be used except by \"update\"\n    this.readByte = function (byte) {\n      // coerce the byte to an int\n      if (typeof byte == 'string') byte = byte.charCodeAt(0);\n      if (skip < 0) {\n        // we have a carry from the previous byte\n        bits |= byte >> -skip;\n      } else {\n        // no carry\n        bits = byte << skip & 248;\n      }\n      if (skip > 3) {\n        // not enough data to produce a character, get us another one\n        skip -= 8;\n        return 1;\n      }\n      if (skip < 4) {\n        // produce a character\n        this.output += alphabet[bits >> 3];\n        skip += 5;\n      }\n      return 0;\n    };\n\n    // Flush any remaining bits left in the stream\n    this.finish = function (check) {\n      var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '');\n      this.output = '';\n      return output;\n    };\n  }\n\n  /**\n   * Process additional input\n   *\n   * input: string of bytes to convert\n   * flush: boolean, should we flush any trailing bits left\n   *        in the stream\n   * returns: a string of characters representing 'input' in base32\n   */\n\n  Encoder.prototype.update = function (input, flush) {\n    for (var i = 0; i < input.length;) {\n      i += this.readByte(input[i]);\n    }\n    // consume all output\n    var output = this.output;\n    this.output = '';\n    if (flush) {\n      output += this.finish();\n    }\n    return output;\n  };\n\n  // Functions analogously to Encoder\n\n  function Decoder() {\n    var skip = 0; // how many bits we have from the previous character\n    var byte = 0; // current byte we're producing\n\n    this.output = '';\n\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    this.readChar = function (char) {\n      if (typeof char != 'string') {\n        if (typeof char == 'number') {\n          char = String.fromCharCode(char);\n        }\n      }\n      char = char.toLowerCase();\n      var val = lookup()[char];\n      if (typeof val == 'undefined') {\n        // character does not exist in our lookup table\n        return; // skip silently. An alternative would be:\n        // throw Error('Could not find character \"' + char + '\" in lookup table.')\n      }\n\n      val <<= 3; // move to the high bits\n      byte |= val >>> skip;\n      skip += 5;\n      if (skip >= 8) {\n        // we have enough to preduce output\n        this.output += String.fromCharCode(byte);\n        skip -= 8;\n        if (skip > 0) byte = val << 5 - skip & 255;else byte = 0;\n      }\n    };\n    this.finish = function (check) {\n      var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '');\n      this.output = '';\n      return output;\n    };\n  }\n  Decoder.prototype.update = function (input, flush) {\n    for (var i = 0; i < input.length; i++) {\n      this.readChar(input[i]);\n    }\n    var output = this.output;\n    this.output = '';\n    if (flush) {\n      output += this.finish();\n    }\n    return output;\n  };\n\n  /** Convenience functions\n   *\n   * These are the ones to use if you just have a string and\n   * want to convert it without dealing with streams and whatnot.\n   */\n\n  // String of data goes in, Base32-encoded string comes out.\n  function encode(input) {\n    var encoder = new Encoder();\n    var output = encoder.update(input, true);\n    return output;\n  }\n\n  // Base32-encoded string goes in, decoded data comes out.\n  function decode(input) {\n    var decoder = new Decoder();\n    var output = decoder.update(input, true);\n    return output;\n  }\n\n  /**\n   * sha1 functions wrap the hash function from Node.js\n   *\n   * Several ways to use this:\n   *\n   *     var hash = base32.sha1('Hello World')\n   *     base32.sha1(process.stdin, function (err, data) {\n   *       if (err) return console.log(\"Something went wrong: \" + err.message)\n   *       console.log(\"Your SHA1: \" + data)\n   *     }\n   *     base32.sha1.file('/my/file/path', console.log)\n   */\n\n  var crypto, fs;\n  function sha1(input, cb) {\n    if (typeof crypto == 'undefined') crypto = require('crypto');\n    var hash = crypto.createHash('sha1');\n    hash.digest = function (digest) {\n      return function () {\n        return encode(digest.call(this, 'binary'));\n      };\n    }(hash.digest);\n    if (cb) {\n      // streaming\n      if (typeof input == 'string' || Buffer.isBuffer(input)) {\n        try {\n          return cb(null, sha1(input));\n        } catch (err) {\n          return cb(err, null);\n        }\n      }\n      if (!typeof input.on == 'function') return cb({\n        message: \"Not a stream!\"\n      });\n      input.on('data', function (chunk) {\n        hash.update(chunk);\n      });\n      input.on('end', function () {\n        cb(null, hash.digest());\n      });\n      return;\n    }\n\n    // non-streaming\n    if (input) {\n      return hash.update(input).digest();\n    }\n    return hash;\n  }\n  sha1.file = function (filename, cb) {\n    if (filename == '-') {\n      process.stdin.resume();\n      return sha1(process.stdin, cb);\n    }\n    if (typeof fs == 'undefined') fs = require('fs');\n    return fs.stat(filename, function (err, stats) {\n      if (err) return cb(err, null);\n      if (stats.isDirectory()) return cb({\n        dir: true,\n        message: \"Is a directory\"\n      });\n      return sha1(require('fs').createReadStream(filename), cb);\n    });\n  };\n  var base32 = {\n    Decoder: Decoder,\n    Encoder: Encoder,\n    encode: encode,\n    decode: decode,\n    sha1: sha1\n  };\n  if (typeof window !== 'undefined') {\n    // we're in a browser - OMG!\n    window.base32 = base32;\n  }\n  if (typeof module !== 'undefined' && module.exports) {\n    // nodejs/browserify\n    module.exports = base32;\n  }\n})();","map":{"version":3,"names":["alphabet","alias","o","i","l","s","lookup","table","length","key","hasOwnProperty","Encoder","skip","bits","output","readByte","byte","charCodeAt","finish","check","prototype","update","input","flush","Decoder","readChar","char","String","fromCharCode","toLowerCase","val","encode","encoder","decode","decoder","crypto","fs","sha1","cb","require","hash","createHash","digest","call","Buffer","isBuffer","err","on","message","chunk","file","filename","process","stdin","resume","stat","stats","isDirectory","dir","createReadStream","base32","window","module","exports"],"sources":["/home/benjamin/Documents/42/42_ft_transcendence/front/node_modules/base32/lib/base32.js"],"sourcesContent":[";(function(){\n\n// This would be the place to edit if you want a different\n// Base32 implementation\n\nvar alphabet = '0123456789abcdefghjkmnpqrtuvwxyz'\nvar alias = { o:0, i:1, l:1, s:5 }\n\n/**\n * Build a lookup table and memoize it\n *\n * Return an object that maps a character to its\n * byte value.\n */\n\nvar lookup = function() {\n    var table = {}\n    // Invert 'alphabet'\n    for (var i = 0; i < alphabet.length; i++) {\n        table[alphabet[i]] = i\n    }\n    // Splice in 'alias'\n    for (var key in alias) {\n        if (!alias.hasOwnProperty(key)) continue\n        table[key] = table['' + alias[key]]\n    }\n    lookup = function() { return table }\n    return table\n}\n\n/**\n * A streaming encoder\n *\n *     var encoder = new base32.Encoder()\n *     var output1 = encoder.update(input1)\n *     var output2 = encoder.update(input2)\n *     var lastoutput = encode.update(lastinput, true)\n */\n\nfunction Encoder() {\n    var skip = 0 // how many bits we will skip from the first byte\n    var bits = 0 // 5 high bits, carry from one byte to the next\n\n    this.output = ''\n\n    // Read one byte of input\n    // Should not really be used except by \"update\"\n    this.readByte = function(byte) {\n        // coerce the byte to an int\n        if (typeof byte == 'string') byte = byte.charCodeAt(0)\n\n        if (skip < 0) { // we have a carry from the previous byte\n            bits |= (byte >> (-skip))\n        } else { // no carry\n            bits = (byte << skip) & 248\n        }\n\n        if (skip > 3) {\n            // not enough data to produce a character, get us another one\n            skip -= 8\n            return 1\n        }\n\n        if (skip < 4) {\n            // produce a character\n            this.output += alphabet[bits >> 3]\n            skip += 5\n        }\n\n        return 0\n    }\n\n    // Flush any remaining bits left in the stream\n    this.finish = function(check) {\n        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '')\n        this.output = ''\n        return output\n    }\n}\n\n/**\n * Process additional input\n *\n * input: string of bytes to convert\n * flush: boolean, should we flush any trailing bits left\n *        in the stream\n * returns: a string of characters representing 'input' in base32\n */\n\nEncoder.prototype.update = function(input, flush) {\n    for (var i = 0; i < input.length; ) {\n        i += this.readByte(input[i])\n    }\n    // consume all output\n    var output = this.output\n    this.output = ''\n    if (flush) {\n      output += this.finish()\n    }\n    return output\n}\n\n// Functions analogously to Encoder\n\nfunction Decoder() {\n    var skip = 0 // how many bits we have from the previous character\n    var byte = 0 // current byte we're producing\n\n    this.output = ''\n\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    this.readChar = function(char) {\n        if (typeof char != 'string'){\n            if (typeof char == 'number') {\n                char = String.fromCharCode(char)\n            }\n        }\n        char = char.toLowerCase()\n        var val = lookup()[char]\n        if (typeof val == 'undefined') {\n            // character does not exist in our lookup table\n            return // skip silently. An alternative would be:\n            // throw Error('Could not find character \"' + char + '\" in lookup table.')\n        }\n        val <<= 3 // move to the high bits\n        byte |= val >>> skip\n        skip += 5\n        if (skip >= 8) {\n            // we have enough to preduce output\n            this.output += String.fromCharCode(byte)\n            skip -= 8\n            if (skip > 0) byte = (val << (5 - skip)) & 255\n            else byte = 0\n        }\n\n    }\n\n    this.finish = function(check) {\n        var output = this.output + (skip < 0 ? alphabet[bits >> 3] : '') + (check ? '$' : '')\n        this.output = ''\n        return output\n    }\n}\n\nDecoder.prototype.update = function(input, flush) {\n    for (var i = 0; i < input.length; i++) {\n        this.readChar(input[i])\n    }\n    var output = this.output\n    this.output = ''\n    if (flush) {\n      output += this.finish()\n    }\n    return output\n}\n\n/** Convenience functions\n *\n * These are the ones to use if you just have a string and\n * want to convert it without dealing with streams and whatnot.\n */\n\n// String of data goes in, Base32-encoded string comes out.\nfunction encode(input) {\n  var encoder = new Encoder()\n  var output = encoder.update(input, true)\n  return output\n}\n\n// Base32-encoded string goes in, decoded data comes out.\nfunction decode(input) {\n    var decoder = new Decoder()\n    var output = decoder.update(input, true)\n    return output\n}\n\n/**\n * sha1 functions wrap the hash function from Node.js\n *\n * Several ways to use this:\n *\n *     var hash = base32.sha1('Hello World')\n *     base32.sha1(process.stdin, function (err, data) {\n *       if (err) return console.log(\"Something went wrong: \" + err.message)\n *       console.log(\"Your SHA1: \" + data)\n *     }\n *     base32.sha1.file('/my/file/path', console.log)\n */\n\nvar crypto, fs\nfunction sha1(input, cb) {\n    if (typeof crypto == 'undefined') crypto = require('crypto')\n    var hash = crypto.createHash('sha1')\n    hash.digest = (function(digest) {\n        return function() {\n            return encode(digest.call(this, 'binary'))\n        }\n    })(hash.digest)\n    if (cb) { // streaming\n        if (typeof input == 'string' || Buffer.isBuffer(input)) {\n            try {\n                return cb(null, sha1(input))\n            } catch (err) {\n                return cb(err, null)\n            }\n        }\n        if (!typeof input.on == 'function') return cb({ message: \"Not a stream!\" })\n        input.on('data', function(chunk) { hash.update(chunk) })\n        input.on('end', function() { cb(null, hash.digest()) })\n        return\n    }\n\n    // non-streaming\n    if (input) {\n        return hash.update(input).digest()\n    }\n    return hash\n}\nsha1.file = function(filename, cb) {\n    if (filename == '-') {\n        process.stdin.resume()\n        return sha1(process.stdin, cb)\n    }\n    if (typeof fs == 'undefined') fs = require('fs')\n    return fs.stat(filename, function(err, stats) {\n        if (err) return cb(err, null)\n        if (stats.isDirectory()) return cb({ dir: true, message: \"Is a directory\" })\n        return sha1(require('fs').createReadStream(filename), cb)\n    })\n}\n\nvar base32 = {\n    Decoder: Decoder,\n    Encoder: Encoder,\n    encode: encode,\n    decode: decode,\n    sha1: sha1\n}\n\nif (typeof window !== 'undefined') {\n  // we're in a browser - OMG!\n  window.base32 = base32\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  // nodejs/browserify\n  module.exports = base32\n}\n})();\n"],"mappings":"AAAA;AAAC,CAAC,YAAU;EAEZ;EACA;;EAEA,IAAIA,QAAQ,GAAG,kCAAkC;EACjD,IAAIC,KAAK,GAAG;IAAEC,CAAC,EAAC,CAAC;IAAEC,CAAC,EAAC,CAAC;IAAEC,CAAC,EAAC,CAAC;IAAEC,CAAC,EAAC;EAAE,CAAC;;EAElC;AACA;AACA;AACA;AACA;AACA;;EAEA,IAAIC,MAAM,GAAG,SAAAA,CAAA,EAAW;IACpB,IAAIC,KAAK,GAAG,CAAC,CAAC;IACd;IACA,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAACQ,MAAM,EAAEL,CAAC,EAAE,EAAE;MACtCI,KAAK,CAACP,QAAQ,CAACG,CAAC,CAAC,CAAC,GAAGA,CAAC;IAC1B;IACA;IACA,KAAK,IAAIM,GAAG,IAAIR,KAAK,EAAE;MACnB,IAAI,CAACA,KAAK,CAACS,cAAc,CAACD,GAAG,CAAC,EAAE;MAChCF,KAAK,CAACE,GAAG,CAAC,GAAGF,KAAK,CAAC,EAAE,GAAGN,KAAK,CAACQ,GAAG,CAAC,CAAC;IACvC;IACAH,MAAM,GAAG,SAAAA,CAAA,EAAW;MAAE,OAAOC,KAAK;IAAC,CAAC;IACpC,OAAOA,KAAK;EAChB,CAAC;;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA,SAASI,OAAOA,CAAA,EAAG;IACf,IAAIC,IAAI,GAAG,CAAC,EAAC;IACb,IAAIC,IAAI,GAAG,CAAC,EAAC;;IAEb,IAAI,CAACC,MAAM,GAAG,EAAE;;IAEhB;IACA;IACA,IAAI,CAACC,QAAQ,GAAG,UAASC,IAAI,EAAE;MAC3B;MACA,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAEA,IAAI,GAAGA,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC;MAEtD,IAAIL,IAAI,GAAG,CAAC,EAAE;QAAE;QACZC,IAAI,IAAKG,IAAI,IAAK,CAACJ,IAAM;MAC7B,CAAC,MAAM;QAAE;QACLC,IAAI,GAAIG,IAAI,IAAIJ,IAAI,GAAI,GAAG;MAC/B;MAEA,IAAIA,IAAI,GAAG,CAAC,EAAE;QACV;QACAA,IAAI,IAAI,CAAC;QACT,OAAO,CAAC;MACZ;MAEA,IAAIA,IAAI,GAAG,CAAC,EAAE;QACV;QACA,IAAI,CAACE,MAAM,IAAId,QAAQ,CAACa,IAAI,IAAI,CAAC,CAAC;QAClCD,IAAI,IAAI,CAAC;MACb;MAEA,OAAO,CAAC;IACZ,CAAC;;IAED;IACA,IAAI,CAACM,MAAM,GAAG,UAASC,KAAK,EAAE;MAC1B,IAAIL,MAAM,GAAG,IAAI,CAACA,MAAM,IAAIF,IAAI,GAAG,CAAC,GAAGZ,QAAQ,CAACa,IAAI,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,IAAIM,KAAK,GAAG,GAAG,GAAG,EAAE,CAAC;MACrF,IAAI,CAACL,MAAM,GAAG,EAAE;MAChB,OAAOA,MAAM;IACjB,CAAC;EACL;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEAH,OAAO,CAACS,SAAS,CAACC,MAAM,GAAG,UAASC,KAAK,EAAEC,KAAK,EAAE;IAC9C,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,KAAK,CAACd,MAAM,GAAI;MAChCL,CAAC,IAAI,IAAI,CAACY,QAAQ,CAACO,KAAK,CAACnB,CAAC,CAAC,CAAC;IAChC;IACA;IACA,IAAIW,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,IAAI,CAACA,MAAM,GAAG,EAAE;IAChB,IAAIS,KAAK,EAAE;MACTT,MAAM,IAAI,IAAI,CAACI,MAAM,CAAC,CAAC;IACzB;IACA,OAAOJ,MAAM;EACjB,CAAC;;EAED;;EAEA,SAASU,OAAOA,CAAA,EAAG;IACf,IAAIZ,IAAI,GAAG,CAAC,EAAC;IACb,IAAII,IAAI,GAAG,CAAC,EAAC;;IAEb,IAAI,CAACF,MAAM,GAAG,EAAE;;IAEhB;IACA;IACA;IACA,IAAI,CAACW,QAAQ,GAAG,UAASC,IAAI,EAAE;MAC3B,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAC;QACxB,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;UACzBA,IAAI,GAAGC,MAAM,CAACC,YAAY,CAACF,IAAI,CAAC;QACpC;MACJ;MACAA,IAAI,GAAGA,IAAI,CAACG,WAAW,CAAC,CAAC;MACzB,IAAIC,GAAG,GAAGxB,MAAM,CAAC,CAAC,CAACoB,IAAI,CAAC;MACxB,IAAI,OAAOI,GAAG,IAAI,WAAW,EAAE;QAC3B;QACA,OAAM,CAAC;QACP;MACJ;;MACAA,GAAG,KAAK,CAAC,EAAC;MACVd,IAAI,IAAIc,GAAG,KAAKlB,IAAI;MACpBA,IAAI,IAAI,CAAC;MACT,IAAIA,IAAI,IAAI,CAAC,EAAE;QACX;QACA,IAAI,CAACE,MAAM,IAAIa,MAAM,CAACC,YAAY,CAACZ,IAAI,CAAC;QACxCJ,IAAI,IAAI,CAAC;QACT,IAAIA,IAAI,GAAG,CAAC,EAAEI,IAAI,GAAIc,GAAG,IAAK,CAAC,GAAGlB,IAAK,GAAI,GAAG,MACzCI,IAAI,GAAG,CAAC;MACjB;IAEJ,CAAC;IAED,IAAI,CAACE,MAAM,GAAG,UAASC,KAAK,EAAE;MAC1B,IAAIL,MAAM,GAAG,IAAI,CAACA,MAAM,IAAIF,IAAI,GAAG,CAAC,GAAGZ,QAAQ,CAACa,IAAI,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,IAAIM,KAAK,GAAG,GAAG,GAAG,EAAE,CAAC;MACrF,IAAI,CAACL,MAAM,GAAG,EAAE;MAChB,OAAOA,MAAM;IACjB,CAAC;EACL;EAEAU,OAAO,CAACJ,SAAS,CAACC,MAAM,GAAG,UAASC,KAAK,EAAEC,KAAK,EAAE;IAC9C,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,KAAK,CAACd,MAAM,EAAEL,CAAC,EAAE,EAAE;MACnC,IAAI,CAACsB,QAAQ,CAACH,KAAK,CAACnB,CAAC,CAAC,CAAC;IAC3B;IACA,IAAIW,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,IAAI,CAACA,MAAM,GAAG,EAAE;IAChB,IAAIS,KAAK,EAAE;MACTT,MAAM,IAAI,IAAI,CAACI,MAAM,CAAC,CAAC;IACzB;IACA,OAAOJ,MAAM;EACjB,CAAC;;EAED;AACA;AACA;AACA;AACA;;EAEA;EACA,SAASiB,MAAMA,CAACT,KAAK,EAAE;IACrB,IAAIU,OAAO,GAAG,IAAIrB,OAAO,CAAC,CAAC;IAC3B,IAAIG,MAAM,GAAGkB,OAAO,CAACX,MAAM,CAACC,KAAK,EAAE,IAAI,CAAC;IACxC,OAAOR,MAAM;EACf;;EAEA;EACA,SAASmB,MAAMA,CAACX,KAAK,EAAE;IACnB,IAAIY,OAAO,GAAG,IAAIV,OAAO,CAAC,CAAC;IAC3B,IAAIV,MAAM,GAAGoB,OAAO,CAACb,MAAM,CAACC,KAAK,EAAE,IAAI,CAAC;IACxC,OAAOR,MAAM;EACjB;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA,IAAIqB,MAAM,EAAEC,EAAE;EACd,SAASC,IAAIA,CAACf,KAAK,EAAEgB,EAAE,EAAE;IACrB,IAAI,OAAOH,MAAM,IAAI,WAAW,EAAEA,MAAM,GAAGI,OAAO,CAAC,QAAQ,CAAC;IAC5D,IAAIC,IAAI,GAAGL,MAAM,CAACM,UAAU,CAAC,MAAM,CAAC;IACpCD,IAAI,CAACE,MAAM,GAAI,UAASA,MAAM,EAAE;MAC5B,OAAO,YAAW;QACd,OAAOX,MAAM,CAACW,MAAM,CAACC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;MAC9C,CAAC;IACL,CAAC,CAAEH,IAAI,CAACE,MAAM,CAAC;IACf,IAAIJ,EAAE,EAAE;MAAE;MACN,IAAI,OAAOhB,KAAK,IAAI,QAAQ,IAAIsB,MAAM,CAACC,QAAQ,CAACvB,KAAK,CAAC,EAAE;QACpD,IAAI;UACA,OAAOgB,EAAE,CAAC,IAAI,EAAED,IAAI,CAACf,KAAK,CAAC,CAAC;QAChC,CAAC,CAAC,OAAOwB,GAAG,EAAE;UACV,OAAOR,EAAE,CAACQ,GAAG,EAAE,IAAI,CAAC;QACxB;MACJ;MACA,IAAI,CAAC,OAAOxB,KAAK,CAACyB,EAAE,IAAI,UAAU,EAAE,OAAOT,EAAE,CAAC;QAAEU,OAAO,EAAE;MAAgB,CAAC,CAAC;MAC3E1B,KAAK,CAACyB,EAAE,CAAC,MAAM,EAAE,UAASE,KAAK,EAAE;QAAET,IAAI,CAACnB,MAAM,CAAC4B,KAAK,CAAC;MAAC,CAAC,CAAC;MACxD3B,KAAK,CAACyB,EAAE,CAAC,KAAK,EAAE,YAAW;QAAET,EAAE,CAAC,IAAI,EAAEE,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC;MAAC,CAAC,CAAC;MACvD;IACJ;;IAEA;IACA,IAAIpB,KAAK,EAAE;MACP,OAAOkB,IAAI,CAACnB,MAAM,CAACC,KAAK,CAAC,CAACoB,MAAM,CAAC,CAAC;IACtC;IACA,OAAOF,IAAI;EACf;EACAH,IAAI,CAACa,IAAI,GAAG,UAASC,QAAQ,EAAEb,EAAE,EAAE;IAC/B,IAAIa,QAAQ,IAAI,GAAG,EAAE;MACjBC,OAAO,CAACC,KAAK,CAACC,MAAM,CAAC,CAAC;MACtB,OAAOjB,IAAI,CAACe,OAAO,CAACC,KAAK,EAAEf,EAAE,CAAC;IAClC;IACA,IAAI,OAAOF,EAAE,IAAI,WAAW,EAAEA,EAAE,GAAGG,OAAO,CAAC,IAAI,CAAC;IAChD,OAAOH,EAAE,CAACmB,IAAI,CAACJ,QAAQ,EAAE,UAASL,GAAG,EAAEU,KAAK,EAAE;MAC1C,IAAIV,GAAG,EAAE,OAAOR,EAAE,CAACQ,GAAG,EAAE,IAAI,CAAC;MAC7B,IAAIU,KAAK,CAACC,WAAW,CAAC,CAAC,EAAE,OAAOnB,EAAE,CAAC;QAAEoB,GAAG,EAAE,IAAI;QAAEV,OAAO,EAAE;MAAiB,CAAC,CAAC;MAC5E,OAAOX,IAAI,CAACE,OAAO,CAAC,IAAI,CAAC,CAACoB,gBAAgB,CAACR,QAAQ,CAAC,EAAEb,EAAE,CAAC;IAC7D,CAAC,CAAC;EACN,CAAC;EAED,IAAIsB,MAAM,GAAG;IACTpC,OAAO,EAAEA,OAAO;IAChBb,OAAO,EAAEA,OAAO;IAChBoB,MAAM,EAAEA,MAAM;IACdE,MAAM,EAAEA,MAAM;IACdI,IAAI,EAAEA;EACV,CAAC;EAED,IAAI,OAAOwB,MAAM,KAAK,WAAW,EAAE;IACjC;IACAA,MAAM,CAACD,MAAM,GAAGA,MAAM;EACxB;EAEA,IAAI,OAAOE,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,OAAO,EAAE;IACnD;IACAD,MAAM,CAACC,OAAO,GAAGH,MAAM;EACzB;AACA,CAAC,EAAE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}