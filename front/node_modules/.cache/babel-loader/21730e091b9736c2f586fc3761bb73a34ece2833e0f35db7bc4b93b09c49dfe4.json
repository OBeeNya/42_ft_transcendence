{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInjectionProviders = void 0;\n/**\n * check if x is OptionalFactoryDependency, based on prototype presence\n * (to avoid classes with a static 'token' field)\n * @param x\n * @returns x is OptionalFactoryDependency\n */\nfunction isOptionalFactoryDependency(x) {\n  return !!((x === null || x === void 0 ? void 0 : x.token) && !(x === null || x === void 0 ? void 0 : x.prototype));\n}\nconst mapInjectToTokens = t => isOptionalFactoryDependency(t) ? t.token : t;\n/**\n *\n * @param providers List of a module's providers\n * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)\n * @returns All the providers needed for the tokens' injection (searched recursively)\n */\nfunction getInjectionProviders(providers, tokens) {\n  const result = [];\n  let search = tokens.map(mapInjectToTokens);\n  while (search.length > 0) {\n    const match = (providers !== null && providers !== void 0 ? providers : []).filter(p => !result.includes(p) && (\n    // this prevents circular loops and duplication\n    search.includes(p) || search.includes(p === null || p === void 0 ? void 0 : p.provide)));\n    result.push(...match);\n    // get injection tokens of the matched providers, if any\n    search = match.filter(p => p === null || p === void 0 ? void 0 : p.inject).map(p => p.inject).flat().map(mapInjectToTokens);\n  }\n  return result;\n}\nexports.getInjectionProviders = getInjectionProviders;","map":{"version":3,"names":["Object","defineProperty","exports","value","getInjectionProviders","isOptionalFactoryDependency","x","token","prototype","mapInjectToTokens","t","providers","tokens","result","search","map","length","match","filter","p","includes","provide","push","inject","flat"],"sources":["/home/benjamin/Documents/42/42_ft_transcendence/front/node_modules/@nestjs/common/module-utils/utils/get-injection-providers.util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInjectionProviders = void 0;\n/**\n * check if x is OptionalFactoryDependency, based on prototype presence\n * (to avoid classes with a static 'token' field)\n * @param x\n * @returns x is OptionalFactoryDependency\n */\nfunction isOptionalFactoryDependency(x) {\n    return !!((x === null || x === void 0 ? void 0 : x.token) && !(x === null || x === void 0 ? void 0 : x.prototype));\n}\nconst mapInjectToTokens = (t) => isOptionalFactoryDependency(t) ? t.token : t;\n/**\n *\n * @param providers List of a module's providers\n * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)\n * @returns All the providers needed for the tokens' injection (searched recursively)\n */\nfunction getInjectionProviders(providers, tokens) {\n    const result = [];\n    let search = tokens.map(mapInjectToTokens);\n    while (search.length > 0) {\n        const match = (providers !== null && providers !== void 0 ? providers : []).filter(p => !result.includes(p) && // this prevents circular loops and duplication\n            (search.includes(p) || search.includes(p === null || p === void 0 ? void 0 : p.provide)));\n        result.push(...match);\n        // get injection tokens of the matched providers, if any\n        search = match\n            .filter(p => p === null || p === void 0 ? void 0 : p.inject)\n            .map(p => p.inject)\n            .flat()\n            .map(mapInjectToTokens);\n    }\n    return result;\n}\nexports.getInjectionProviders = getInjectionProviders;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,qBAAqB,GAAG,KAAK,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,CAAC,EAAE;EACpC,OAAO,CAAC,EAAE,CAACA,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACC,KAAK,KAAK,EAAED,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACE,SAAS,CAAC,CAAC;AACtH;AACA,MAAMC,iBAAiB,GAAIC,CAAC,IAAKL,2BAA2B,CAACK,CAAC,CAAC,GAAGA,CAAC,CAACH,KAAK,GAAGG,CAAC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,qBAAqBA,CAACO,SAAS,EAAEC,MAAM,EAAE;EAC9C,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIC,MAAM,GAAGF,MAAM,CAACG,GAAG,CAACN,iBAAiB,CAAC;EAC1C,OAAOK,MAAM,CAACE,MAAM,GAAG,CAAC,EAAE;IACtB,MAAMC,KAAK,GAAG,CAACN,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,EAAE,EAAEO,MAAM,CAACC,CAAC,IAAI,CAACN,MAAM,CAACO,QAAQ,CAACD,CAAC,CAAC;IAAI;IAC1GL,MAAM,CAACM,QAAQ,CAACD,CAAC,CAAC,IAAIL,MAAM,CAACM,QAAQ,CAACD,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACE,OAAO,CAAC,CAAC,CAAC;IAC7FR,MAAM,CAACS,IAAI,CAAC,GAAGL,KAAK,CAAC;IACrB;IACAH,MAAM,GAAGG,KAAK,CACTC,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACI,MAAM,CAAC,CAC3DR,GAAG,CAACI,CAAC,IAAIA,CAAC,CAACI,MAAM,CAAC,CAClBC,IAAI,CAAC,CAAC,CACNT,GAAG,CAACN,iBAAiB,CAAC;EAC/B;EACA,OAAOI,MAAM;AACjB;AACAX,OAAO,CAACE,qBAAqB,GAAGA,qBAAqB"},"metadata":{},"sourceType":"script","externalDependencies":[]}